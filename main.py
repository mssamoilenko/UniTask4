#Загальна постаовка завдання.

# В ході виконання індивідуального завдання під час практики кожен студент має розробити прикладну програму з використанням елементів бібліотеки TKinter, яка при завантаженні надавала б можливість отримати результати виконання кожної з реалізованих задач.
#
# Оформлення прикладної програми виконується в довільному, інтуїтивно зрозумілому стилі із дотриманням усіх обов’язкових.
#
# Обов’язкові вимоги до оформлення програми:
#
# -Передбачити наявність головної форми, через яку можна запустити кожне з виконаних завдань та довідки, у якій вказується ПІБ та група автора програми.
#
# -Перехід до кожного окремо взятого завдання та його запуск виконується з використанням допоміжних форм, на яких за допомогою елементів форми можна вносити вхідні параметри (якщо це передбачено умовою завдання).
#
# -При переході до кожного з завдань користувач повинен бачити умову завдання, яке виконується. Представлення формул на формах передбачається через рисунки.
#
# -Для всіх без виключення завдань передбачити перевірку вхідних даних на предмет коректності введення інформації. У разі коли користувач виконав помилкове введення даних необхідно передбачити появу «підказки», яка б надавала можливість зрозуміти причину відмови виконання програми.
#
# -При виведенні даних обов’язково виводити тільки доцільну кількість десяткових знаків після коми.
#
# -Завдання 4 повинно виконуватись в повному обсязі. Передбачити можливість вводити назви файлів через елемент TextBox. За фактом виконання завдання користувач повинен отримати відповідне повідомлення.

# ЗАВДАННЯ 4. ОПЕРАЦІЇ З ФАЙЛАМИ.

# 1. Скласти схему алгоритму і програму обробки текстової інформації:
#  Зв'язати файлову змінну з текстовим файлом на диску.
#  Прочитати інформацію з цього файлу в програмні змінні відповідних
# типів.
#  Виконати необхідні дії з отриманими змінними і представити результат
# у необхідному вигляді.

# 2. Вказівки для складання програми і її рішення.
#  Схему алгоритму і програму скласти з перевіркою існування файлу на
# диску.
#  Передбачити можливість роботи з файлами невизначеної заздалегідь
# довжини.
#  Виконати тестування і налагодження програми, забезпечивши
# перевірку всіх її гілок.

# 3. Методичні вказівки до завдання 4.

# Варіант завдання 23 я виконую

# 22. Дано символьний файл f . Групи символів, розділені пробілами (одним
# чи декількома), які не містять пробілів усередині себе, будемо надалі називати
# словами. Видалити з файлу всі однобуквені слова і зайві пробіли. Результат
# записати у файл g .

# 23. Дано символьний файл f . Знайти саме довге слово (див. попередню
# задачу) серед слів, друга буква яких є "e"; якщо слів з найбільшою довжиною
# декілька, то знайти останнє. Якщо таких слів немає взагалі, то сповістити про
# це. Вирішити цю задачу:
# а) вважаючи, що слова складаються не більш ніж з 10-ти символів;
# б) без обмеження на число символів у слові.

import tkinter as tk
from tkinter import messagebox, filedialog
import string

def open_file():
    file_path = entry_file.get()
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            data = f.read()
            result = process_data(data)
            text_result.delete(1.0, tk.END)
            text_result.insert(tk.END, result)
    except FileNotFoundError:
        messagebox.showerror("Помилка", "Файл не знайдено!")

def process_data(data):
    # Видаляємо знаки пунктуації з тексту
    translator = str.maketrans('', '', string.punctuation)
    cleaned_data = data.translate(translator)

    # Розділяємо текст на слова
    words = cleaned_data.split()

    # Видаляємо однобуквені слова
    words = [word for word in words if len(word) > 1]

    # Фільтруємо слова, де друга буква "e"
    filtered_words = [word for word in words if len(word) > 1 and word[1].lower() == 'е']

    if not filtered_words:
        return "Слів з другою буквою 'e' не знайдено."

    # Знаходимо найдовше слово
    longest_word = max(filtered_words, key=len)

    # Якщо є кілька слів з однаковою довжиною, вибираємо останнє
    longest_words = [word for word in filtered_words if len(word) == len(longest_word)]
    longest_word = longest_words[-1]

    return f"Найдовше слово з другою буквою 'e': {longest_word}"


def save_result():
    result = text_result.get(1.0, tk.END)
    file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text files", "*.txt")])
    if file_path:
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(result)
        messagebox.showinfo("Успіх", "Результат збережено!")


# Головне вікно програми
root = tk.Tk()
root.title("Завдання 4")

# Форма для завдання 4
frame = tk.Frame(root)
frame.pack(padx=10, pady=10)

label_file = tk.Label(frame, text="Шлях до файлу:")
label_file.grid(row=0, column=0, sticky='w')

entry_file = tk.Entry(frame, width=50)
entry_file.grid(row=0, column=1, padx=5, pady=5)

button_open = tk.Button(frame, text="Відкрити файл", command=open_file)
button_open.grid(row=0, column=2, padx=5, pady=5)

text_result = tk.Text(frame, width=60, height=10)
text_result.grid(row=1, column=0, columnspan=3, pady=10)

button_save = tk.Button(frame, text="Зберегти результат", command=save_result)
button_save.grid(row=2, column=1, pady=10)

# Запуск головного циклу програми
root.mainloop()

# Звіт по навчальній практиці
# Звіт по навчальній практиці повинний включати:
#
# 1.    Титульний аркуш.
#
# 2.    Зміст
#
# 3.    Звіт про виконання кожного завдання, що включає:
#
# 3.1. Тему завдання.
#
# 3.2. Мету завдання.
#
# 3.3. Постановку задачі відповідно до індивідуального варіанта з усіма вихідними даними.
#
# 3.4. Блок-схему алгоритму розв’язання задачі.
#
# 3.5. Лістинги програм, програмних модулів, необхідних для розв’язання задачі.
#
# 3.6. Результати роботи програми у вигляді таблиць, графіків чи скріншотів.
#
# 4.    Висновки по виконаній роботі, що включають опис використаних при розв’язання задачі методів та методик, використаних та складених особисто процедур і функцій, освоєних та використаних студентом вперше навичок програмування.
#
# 5.    Перелік використаної літератури.
#
# Рекомендації стосовно формлення списку літератури
#
#
#
# Пам'ятайте, що всі рисунки (блок-схеми, скріншоти і т.д.), лістинги коду, таблиці і таке інше повинні бути підписані.